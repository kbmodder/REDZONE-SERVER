<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Results & Predictions</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
        }
        .tab-button {
            transition: all 0.3s ease;
        }
        .tab-button.active {
            background-color: #4a5568;
            color: #ffffff;
            border-bottom: 2px solid #ed8936;
        }
        .tab-content {
            transition: opacity 0.3s ease;
        }
        .glow {
            box-shadow: 0 0 10px rgba(237, 137, 54, 0.5);
        }
        .prediction-card {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body class="min-h-screen text-gray-200 font-sans">
    <div class="container mx-auto p-4 sm:p-6">
        <h1 class="text-4xl font-bold text-center mb-6 text-orange-400">KB MODDER SERVERS</h1>
        <div class="flex justify-center mb-4">
            <button id="home-tab" class="tab-button px-4 py-2 mx-2 rounded-t-lg text-lg font-semibold bg-gray-700 hover:bg-gray-600 active">Home</button>
            <button id="results-tab" class="tab-button px-4 py-2 mx-2 rounded-t-lg text-lg font-semibold bg-gray-700 hover:bg-gray-600">Results</button>
        </div>
        <div id="app-root" class="bg-gray-800 rounded-lg p-6 shadow-lg glow">
            <p class="text-lg text-center mb-4">Current Period: <span id="period1m">Loading...</span></p>
        </div>
    </div>

    <script>
        const RESULTS_TO_FETCH = 10;
        let lastPrediction = null;
        let lastPredictionEnhanced = null;
        let lastPredictionAI = null;
        let history = JSON.parse(localStorage.getItem('predictionHistory')) || [];
        let currentTab = 'home';
        let lastMinute = null;

        let state = {
            lastFetchedPeriod: null,
            nextPeriod: null,
            isLoading: false,
            isLive: true,
            results: [],
            mostFrequentNumber: null,
            leastFrequentNumber: null
        };

        function calculateFrequentNumbers(data) {
            const numberCounts = {};
            data.forEach(item => {
                const num = parseInt(item.number);
                numberCounts[num] = (numberCounts[num] || 0) + 1;
            });
            let mostFrequent = null, leastFrequent = null;
            let maxCount = 0, minCount = Infinity;
            Object.entries(numberCounts).forEach(([num, count]) => {
                if (count > maxCount) {
                    mostFrequent = num;
                    maxCount = count;
                }
                if (count < minCount) {
                    leastFrequent = num;
                    minCount = count;
                }
            });
            return { mostFrequent, leastFrequent };
        }

        function predictBigSmall(data) {
            const numbers = data.map(item => parseInt(item.number));
            const lastResult = numbers[0] >= 5 ? 'BIG' : 'SMALL';
            const bigCount1 = numbers.filter(num => num >= 5).length;
            const smallCount1 = 10 - bigCount1;

            let bigCount2 = 0;
            let smallCount2 = 0;
            data.forEach((item, index) => {
                const weight = index === 0 ? 2.0 : 1 + (0.3 * (9 - index));
                if (parseInt(item.number) >= 5) {
                    bigCount2 += weight;
                } else {
                    smallCount2 += weight;
                }
            });

            let streakCount = 1;
            let currentStreak = lastResult;
            for (let i = 1; i < numbers.length; i++) {
                const current = numbers[i] >= 5 ? 'BIG' : 'SMALL';
                if (current === currentStreak) {
                    streakCount++;
                } else {
                    break;
                }
            }

            let alternateCount = 0;
            for (let i = 1; i < numbers.length; i++) {
                if ((numbers[i] >= 5 && numbers[i-1] < 5) || 
                    (numbers[i] < 5 && numbers[i-1] >= 5)) {
                    alternateCount++;
                }
            }

            const { mostFrequent, leastFrequent } = calculateFrequentNumbers(data);
            const mostFrequentBias = mostFrequent >= 5 ? 0.1 : -0.1;
            const leastFrequentBias = leastFrequent >= 5 ? -0.05 : 0.05;

            let prediction;
            let confidence;
            if (bigCount1 > smallCount1) {
                prediction = 'BIG';
                confidence = Math.min(50 + ((bigCount1 - smallCount1) * 10), 90);
            } else if (smallCount1 > bigCount1) {
                prediction = 'SMALL';
                confidence = Math.min(50 + ((smallCount1 - bigCount1) * 10), 90);
            } else {
                if (bigCount2 >= smallCount2) {
                    prediction = 'BIG';
                    confidence = Math.min(70 + ((bigCount2 - smallCount2) * 3), 85);
                } else {
                    prediction = 'SMALL';
                    confidence = Math.min(70 + ((smallCount2 - bigCount2) * 3), 85);
                }
            }

            if (streakCount >= 3) {
                prediction = currentStreak;
                confidence = Math.min(confidence + (streakCount * 5), 95);
            }

            if (alternateCount >= 7) {
                prediction = lastResult === 'BIG' ? 'SMALL' : 'BIG';
                confidence = Math.min(confidence + 7, 95);
            }

            confidence = Math.min(confidence + (prediction === 'BIG' ? mostFrequentBias : leastFrequentBias) * 10, 95);

            return [prediction, confidence, mostFrequent, leastFrequent];
        }

        function predictBigSmallEnhanced(data) {
            const numbers = data.map(item => parseInt(item.number));
            const lastResult = numbers[0] >= 5 ? 'BIG' : 'SMALL';
            const bigCount1 = numbers.filter(num => num >= 5).length;
            const smallCount1 = 10 - bigCount1;

            let bigCount2 = 0;
            let smallCount2 = 0;
            data.forEach((item, index) => {
                const weight = index === 0 ? 2.5 : 1 + (0.4 * (9 - index));
                if (parseInt(item.number) >= 5) {
                    bigCount2 += weight;
                } else {
                    smallCount2 += weight;
                }
            });

            const variance = numbers.reduce((sum, num) => sum + (num - 4.5) ** 2, 0) / numbers.length;
            const varianceFactor = variance < 2 ? 0.8 : 1.2;

            let streakCount = 1;
            let currentStreak = lastResult;
            for (let i = 1; i < numbers.length; i++) {
                const current = numbers[i] >= 5 ? 'BIG' : 'SMALL';
                if (current === currentStreak) {
                    streakCount++;
                } else {
                    break;
                }
            }

            let alternateCount = 0;
            const alternationThreshold = variance > 3 ? 6 : 7;
            for (let i = 1; i < numbers.length; i++) {
                if ((numbers[i] >= 5 && numbers[i-1] < 5) || 
                    (numbers[i] < 5 && numbers[i-1] >= 5)) {
                    alternateCount++;
                }
            }

            const { mostFrequent, leastFrequent } = calculateFrequentNumbers(data);
            const mostFrequentBias = mostFrequent >= 5 ? 0.15 : -0.15;
            const leastFrequentBias = leastFrequent >= 5 ? -0.07 : 0.07;

            let prediction = lastResult === 'BIG' ? 'SMALL' : 'BIG';
            let confidence;
            if (bigCount1 > smallCount1) {
                confidence = Math.min(50 + ((bigCount1 - smallCount1) * 12), 90) * varianceFactor;
            } else if (smallCount1 > bigCount1) {
                confidence = Math.min(50 + ((smallCount1 - bigCount1) * 12), 90) * varianceFactor;
            } else {
                if (bigCount2 >= smallCount2) {
                    confidence = Math.min(70 + ((bigCount2 - smallCount2) * 4), 85) * varianceFactor;
                } else {
                    confidence = Math.min(70 + ((smallCount2 - bigCount2) * 4), 85) * varianceFactor;
                }
            }

            if (streakCount >= (variance > 3 ? 2 : 3)) {
                confidence = Math.min(confidence + (streakCount * 6), 95);
            }

            if (alternateCount >= alternationThreshold) {
                confidence = Math.min(confidence + 8, 95);
            }

            confidence = Math.min(confidence + (prediction === 'BIG' ? mostFrequentBias : leastFrequentBias) * 15, 95);

            return [prediction, confidence, mostFrequent, leastFrequent];
        }

        function predictBigSmallAI(data) {
            const numbers = data.map(item => parseInt(item.number));
            const lastResult = numbers[0] >= 5 ? 'BIG' : 'SMALL';
            const bigCount1 = numbers.filter(num => num >= 5).length;
            const smallCount1 = 10 - bigCount1;
            let bigCount2 = 0;
            let smallCount2 = 0;
            data.forEach((item, index) => {
                const weight = index === 0 ? 3.0 : 1 + (0.5 * (9 - index));
                if (parseInt(item.number) >= 5) {
                    bigCount2 += weight;
                } else {
                    smallCount2 += weight;
                }
            });
            const mean = numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
            const variance = numbers.reduce((sum, n) => sum + (n - mean) ** 2, 0) / numbers.length;
            const varianceFactor = variance < 8 ? 0.8 : variance > 12 ? 1.2 : 1.0;
            let streakCount = 1;
            let currentStreak = lastResult;
            for (let i = 1; i < numbers.length; i++) {
                const current = numbers[i] >= 5 ? 'BIG' : 'SMALL';
                if (current === currentStreak) {
                    streakCount++;
                } else {
                    break;
                }
            }
            let alternateCount = 0;
            for (let i = 1; i < numbers.length; i++) {
                if ((numbers[i] >= 5 && numbers[i-1] < 5) || 
                    (numbers[i] < 5 && numbers[i-1] >= 5)) {
                    alternateCount++;
                }
            }
            const { mostFrequent, leastFrequent } = calculateFrequentNumbers(data);
            const mostFrequentBias = mostFrequent >= 5 ? 0.2 : -0.2;
            const leastFrequentBias = leastFrequent >= 5 ? -0.1 : 0.1;
            const oddCount = numbers.filter(n => n % 2 === 1).length;
            const evenCount = 10 - oddCount;
            const parityBias = (oddCount > evenCount && lastResult === 'BIG') ? 0.05 : -0.05;
            let cov = 0;
            for (let i = 0; i < numbers.length - 1; i++) {
                const x = numbers[i] >= 5 ? 1 : 0;
                const y = numbers[i + 1] >= 5 ? 1 : 0;
                cov += (x - 0.5) * (y - 0.5);
            }
            const correlation = (numbers.length > 1) ? (cov / (numbers.length - 1)) / 0.25 : 0;
            let prediction = lastResult === 'BIG' ? 'SMALL' : 'BIG';
            let confidence;
            if (bigCount1 > smallCount1) {
                confidence = 50 + ((bigCount1 - smallCount1) * 15);
            } else if (smallCount1 > bigCount1) {
                confidence = 50 + ((smallCount1 - bigCount1) * 15);
            } else {
                if (bigCount2 >= smallCount2) {
                    confidence = 70 + (Math.abs(bigCount2 - smallCount2) * 5);
                } else {
                    confidence = 70 + (Math.abs(bigCount2 - smallCount2) * 5);
                }
            }
            confidence *= varianceFactor;
            if (streakCount >= 4) {
                confidence += 10;
            } else if (streakCount >= 2) {
                confidence += streakCount * 5;
            }
            if (alternateCount >= 8) {
                confidence += 10;
            }
            if (prediction === 'BIG') {
                confidence += mostFrequentBias * 20 + leastFrequentBias * 10 + parityBias * 10;
            } else {
                confidence += -mostFrequentBias * 20 - leastFrequentBias * 10 - parityBias * 10;
            }
            if (correlation < -0.3) {
                confidence += 15;
            }
            confidence = Math.min(Math.max(confidence, 50), 95);
            return [prediction, confidence, mostFrequent, leastFrequent];
        }

        function updateGamePeriod() {
            let now = new Date();
            let h = now.getUTCHours();
            let m = now.getUTCMinutes();
            let totalMinutes = h * 60 + m;
            let formattedDate = now.getUTCFullYear().toString() +
                ("0" + (now.getUTCMonth() + 1)).slice(-2) +
                ("0" + now.getUTCDate()).slice(-2);
            let period = "1000" + (10001 + totalMinutes);
            document.getElementById("period1m").innerText = formattedDate + period;
            return formattedDate + period;
        }

        function generatePrediction(period) {
            if (!state.results || state.results.length === 0) return;
            const [prediction, confidence, mostFrequent, leastFrequent] = predictBigSmall(state.results);
            const [predictionEnhanced, confidenceEnhanced] = predictBigSmallEnhanced(state.results);
            const [predictionAI, confidenceAI] = predictBigSmallAI(state.results);
            lastPrediction = prediction;
            lastPredictionEnhanced = predictionEnhanced;
            lastPredictionAI = predictionAI;
            state.mostFrequentNumber = mostFrequent;
            state.leastFrequentNumber = leastFrequent;
            state.nextPeriod = period;
            history.unshift({
                PERIOD: period,
                number: 'N/A',
                RESULT: 'N/A',
                SERVER ULTRA: prediction,
                SERVER VIP: predictionEnhanced,
                SERVER AI: predictionAI,
                CONFIDENCE: confidence,
                CONFIDENCE VIP: confidenceEnhanced,
               C: confidenceAI,
                time: new Date().toLocaleString()
            });
            if (history.length > 20) {
                history.pop();
            }
            localStorage.setItem('predictionHistory', JSON.stringify(history));
            render();
        }

        function updateUI(data) {
            if (!data || data.length === 0) return;
            const prevResult = data[0];
            const prevPeriod = prevResult.issueNumber;
            const prevNumber = prevResult.number;
            const actualResult = parseInt(prevNumber) >= 5 ? 'BIG' : 'SMALL';

            const historyItem = history.find(item => item.period === prevPeriod);
            if (historyItem && historyItem.number === 'N/A') {
                historyItem.number = prevNumber;
                historyItem.result = actualResult;
                localStorage.setItem('predictionHistory', JSON.stringify(history));
            }
            render();
        }

        function render() {
            const appRoot = document.getElementById('app-root');
            let html = `<p class="text-lg text-center mb-4">Current Period: <span id="period1m">${state.nextPeriod || 'Loading...'}</span></p>`;
            if (state.isLoading) {
                html += '<p class="text-center text-lg">Loading game results...</p>';
            } else if (currentTab === 'home') {
                html += '<div class="prediction-card p-4 bg-gray-700 rounded-lg mb-4">';
                html += `<h2 class="text-2xl font-semibold text-orange-400">Next Prediction (Period: ${state.nextPeriod || 'N/A'})</h2>`;
                html += `<p class="text-lg">Primary Prediction: <span class="font-bold ${lastPrediction === 'BIG' ? 'text-green-400' : 'text-red-400'}">${lastPrediction || 'N/A'}</span> (${history[0]?.confidence.toFixed(2) || 0}%)</p>`;
                html += `<p class="text-lg">Enhanced Prediction: <span class="font-bold ${lastPredictionEnhanced === 'BIG' ? 'text-green-400' : 'text-red-400'}">${lastPredictionEnhanced || 'N/A'}</span> (${history[0]?.confidenceEnhanced.toFixed(2) || 0}%)</p>`;
                html += `<p class="text-lg">AI Prediction: <span class="font-bold ${lastPredictionAI === 'BIG' ? 'text-green-400' : 'text-red-400'}">${lastPredictionAI || 'N/A'}</span> (${history[0]?.confidenceAI.toFixed(2) || 0}%)</p>`;
                html += `<p class="text-lg">Most Frequent Number: ${state.mostFrequentNumber || 'N/A'}</p>`;
                html += `<p class="text-lg">Least Frequent Number: ${state.leastFrequentNumber || 'N/A'}</p>`;
                html += '</div>';
                html += '<h2 class="text-2xl font-semibold text-orange-400 mb-4">Prediction History</h2>';
                html += '<div class="overflow-x-auto"><table class="w-full text-left">';
                html += '<tr class="bg-gray-600"><th class="p-3">Period</th><th>Number</th><th>Result</th><th>Primary Prediction</th><th>Enhanced Prediction</th><th>AI Prediction</th><th>Confidence</th><th>Enhanced Confidence</th><th>AI Confidence</th><th>Time</th></tr>';
                history.slice(0, 10).forEach(item => {
                    html += `<tr class="hover:bg-gray-600">
                        <td class="p-3">${item.period}</td>
                        <td>${item.number}</td>
                        <td>${item.result}</td>
                        <td class="${item.prediction === 'BIG' ? 'text-green-400' : 'text-red-400'}">${item.prediction}</td>
                        <td class="${item.predictionEnhanced === 'BIG' ? 'text-green-400' : 'text-red-400'}">${item.predictionEnhanced}</td>
                        <td class="${item.predictionAI === 'BIG' ? 'text-green-400' : 'text-red-400'}">${item.predictionAI}</td>
                        <td>${item.confidence ? item.confidence.toFixed(2) + '%' : 'N/A'}</td>
                        <td>${item.confidenceEnhanced ? item.confidenceEnhanced.toFixed(2) + '%' : 'N/A'}</td>
                        <td>${item.confidenceAI ? item.confidenceAI.toFixed(2) + '%' : 'N/A'}</td>
                        <td>${item.time}</td>
                    </tr>`;
                });
                html += '</table></div>';
            } else if (currentTab === 'results') {
                html += '<h2 class="text-2xl font-semibold text-orange-400 mb-4">Last 10 Game Results</h2>';
                html += '<div class="overflow-x-auto"><table class="w-full text-left">';
                html += '<tr class="bg-gray-600"><th class="p-3">Issue Number</th><th>Number</th><th>Result</th><th>Time</th></tr>';
                state.results.slice(0, 10).forEach(result => {
                    const resultStatus = parseInt(result.number) >= 5 ? 'BIG' : 'SMALL';
                    html += `<tr class="hover:bg-gray-600">
                        <td class="p-3">${result.issueNumber}</td>
                        <td>${result.number}</td>
                        <td class="${resultStatus === 'BIG' ? 'text-green-400' : 'text-red-400'}">${resultStatus}</td>
                        <td>${result.openTime || 'N/A'}</td>
                    </tr>`;
                });
                html += '</table></div>';
            } else {
                html += '<p class="text-center text-lg">No results available.</p>';
            }
            appRoot.innerHTML = html;
        }

        function fetchMockGameResult() {
            const results = [];
            let lastPeriod = state.lastFetchedPeriod ? BigInt(state.lastFetchedPeriod) : BigInt('20240701001');
            let lastResult = Math.random() < 0.5 ? 'B' : 'S';
            for (let i = 0; i < RESULTS_TO_FETCH; i++) {
                const number = lastResult === 'B' ? (Math.random() < 0.7 ? Math.floor(Math.random() * 5) : Math.floor(Math.random() * 5 + 5))
                                           : (Math.random() < 0.7 ? Math.floor(Math.random() * 5 + 5) : Math.floor(Math.random() * 5));
                lastResult = number >= 5 ? 'B' : 'S';
                results.push({
                    issueNumber: (lastPeriod + BigInt(i)).toString(),
                    number: number.toString(),
                    openTime: new Date(Date.now() - i * 60000).toLocaleString()
                });
            }
            state.lastFetchedPeriod = results[0].issueNumber;
            state.nextPeriod = String(parseInt(results[0].issueNumber) + 1);
            console.log("Using mock data for game results.");
            return results;
        }

        async function fetchGameResult(maxRetries = 3, retryDelay = 2000) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const timestamp = Date.now();
                    const response = await fetch(`https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${timestamp}`);
                    const data = await response.json();
                    if (!data?.data?.list || !Array.isArray(data.data.list) || data.data.list.length === 0) {
                        console.warn(`Attempt ${attempt}: API returned no valid data.`);
                        if (attempt === maxRetries) {
                            state.isLive = false;
                            state.results = fetchMockGameResult();
                            renderErrorNotification();
                            updateUI(state.results);
                            return state.results;
                        }
                        await new Promise(resolve => setTimeout(resolve, retryDelay));
                        continue;
                    }
                    const latestIssue = data.data.list[0].issueNumber;
                    if (state.lastFetchedPeriod && latestIssue <= state.lastFetchedPeriod) {
                        return state.results;
                    }
                    state.isLive = true;
                    state.results = data.data.list.map(item => ({
                        issueNumber: item.issueNumber,
                        number: item.number,
                        openTime: new Date(item.openTime).toLocaleString()
                    })).slice(0, 10);
                    state.lastFetchedPeriod = latestIssue;
                    updateUI(state.results);
                    return state.results;
                } catch (e) {
                    console.error(`Attempt ${attempt}: API error:`, e);
                    if (attempt === maxRetries) {
                        state.isLive = false;
                        state.results = fetchMockGameResult();
                        renderErrorNotification();
                        updateUI(state.results);
                        return state.results;
                    }
                    await new Promise(resolve => setTimeout(resolve, retryDelay));
                }
            }
        }

        function renderErrorNotification() {
            const appRoot = document.getElementById('app-root');
            appRoot.insertAdjacentHTML('afterbegin', `<div class="error-notification p-3 bg-red-900 text-red-100 rounded-lg mb-4 text-center">
                Failed to fetch live data. Using mock data instead.
            </div>`);
        }

        function checkMinuteChange() {
            const now = new Date();
            const currentMinute = now.getUTCMinutes();
            if (lastMinute !== currentMinute) {
                lastMinute = currentMinute;
                const period = updateGamePeriod();
                generatePrediction(period);
            }
        }

        document.getElementById('home-tab').addEventListener('click', () => {
            currentTab = 'home';
            document.getElementById('home-tab').classList.add('active');
            document.getElementById('results-tab').classList.remove('active');
            render();
        });
        document.getElementById('results-tab').addEventListener('click', () => {
            currentTab = 'results';
            document.getElementById('results-tab').classList.add('active');
            document.getElementById('home-tab').classList.remove('active');
            render();
        });

        window.addEventListener('load', async () => {
            state.isLoading = true;
            render();
            await fetchGameResult();
            state.isLoading = false;
            const period = updateGamePeriod();
            generatePrediction(period);
            setInterval(checkMinuteChange, 1000);
            setInterval(async () => {
                const results = await fetchGameResult();
                console.log('Fetched results:', results);
            }, 5000);
        });
    </script>
</body>
</html>